# 4. Longest Substring Without Repeating Characters

#Hard #Array #Binary Search #Divide and Conquer

[toc]

## 1) Question

Given two sorted arrays `nums1` and `nums2` of size `m` and `n` respectively, return **the median** of the two sorted arrays.

The overall run time complexity should be $$O(log (m+n))$$.

**Example 1:**

```structured text
Input: nums1 = [1,3], nums2 = [2]
Output: 2.00000
Explanation: merged array = [1,2,3] and median is 2.
```

**Example 2:**

```structured text
Input: nums1 = [1,2], nums2 = [3,4]
Output: 2.50000
Explanation: merged array = [1,2,3,4] and median is (2 + 3) / 2 = 2.5.
```

**Constraints:**

- `nums1.length == m`
- `nums2.length == n`
- `0 <= m <= 1000`
- `0 <= n <= 1000`
- `1 <= m + n <= 2000`
- `-106 <= nums1[i], nums2[i] <= 106`

## 2) Solution

### ・Binary Search

- Time Complexity: $$ O(log(min(n_1,n_2)) $$
- Space Complexity: $$ O(1) $$

#### a. C++

- Runtime: 0 ms
- Memory: 95.20 MB

```c++
class Solution {
 public:
  double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
    const int n1 = nums1.size();
    const int n2 = nums2.size();
    if (n1 > n2)
      return findMedianSortedArrays(nums2, nums1);

    int l = 0;
    int r = n1;

    while (l <= r) {
      const int partition1 = (l + r) / 2;
      const int partition2 = (n1 + n2 + 1) / 2 - partition1;
      const int maxLeft1 = partition1 == 0 ? INT_MIN : nums1[partition1 - 1];
      const int maxLeft2 = partition2 == 0 ? INT_MIN : nums2[partition2 - 1];
      const int minRight1 = partition1 == n1 ? INT_MAX : nums1[partition1];
      const int minRight2 = partition2 == n2 ? INT_MAX : nums2[partition2];
      if (maxLeft1 <= minRight2 && maxLeft2 <= minRight1)
        return (n1 + n2) % 2 == 0
                   ? (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) * 0.5
                   : max(maxLeft1, maxLeft2);
      else if (maxLeft1 > minRight2)
        r = partition1 - 1;
      else
        l = partition1 + 1;
    }

    throw;
  }
};
```

#### b. Go

- Runtime: 2 ms
- Memory: 6.56 MB

```go
func findMedianSortedArrays(nums1 []int, nums2 []int) float64 {
    if (len(nums1) > len(nums2)) {
        nums1, nums2 = nums2, nums1
    }

    n1, n2 := len(nums1), len(nums2)
    l, r := 0, n1

    const INT_MIN = math.MinInt32
    const INT_MAX = math.MaxInt32

    for (l <= r) {
        partition1 := (l + r) / 2
        partition2 := (n1 + n2 + 1) / 2 - partition1
        
        maxLeft1 := INT_MIN
        if partition1 != 0 {
            maxLeft1 = nums1[partition1 - 1]
        }

        maxLeft2 := INT_MIN
        if partition2 != 0 {
            maxLeft2 = nums2[partition2 - 1]
        }

        minRight1 := INT_MAX
        if partition1 != n1 {
            minRight1 = nums1[partition1]
        }

        minRight2 := INT_MAX
        if partition2 != n2 {
            minRight2 = nums2[partition2]
        }

        if maxLeft1 <= minRight2 && maxLeft2 <= minRight1 {
            if (n1 + n2) % 2 == 0 {
                maxLeft := maxLeft1
                if maxLeft2 > maxLeft {
                    maxLeft = maxLeft2
                }

                minRight := minRight1
                if minRight2 < minRight {
                    minRight = minRight2
                }
                return float64(maxLeft + minRight) / 2.0
            }

            if maxLeft1 > maxLeft2 {
                return float64(maxLeft1)
            }
            return float64(maxLeft2)

        } else if maxLeft1 > minRight2 {
            r = partition1 - 1
        } else {
            l = partition1 + 1
        }
    }
    panic("unreachable")
}
```

#### c. Python

- Runtime: 0 ms
- Memory: 17.64 MB

```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        if len(nums1) > len(nums2):
            nums1, nums2 = nums2, nums1
        
        n1, n2 = len(nums1), len(nums2)
        l, r = 0, n1
        half = (n1 + n2 + 1) // 2

        neg_inf = float("-inf")
        pos_inf = float("inf")

        while l <= r:
            partition1 = (l + r) // 2
            partition2 = half - partition1
            maxLeft1 = neg_inf if partition1 == 0 else nums1[partition1 - 1]
            maxLeft2 = neg_inf if partition2 == 0 else nums2[partition2 - 1]
            minRight1 = pos_inf if partition1 == n1 else nums1[partition1]
            minRight2 = pos_inf if partition2 == n2 else nums2[partition2]
            if maxLeft1 <= minRight2 and maxLeft2 <= minRight1:
                if (n1 + n2) % 2 == 0:
                    return (max(maxLeft1, maxLeft2) + min(minRight1, minRight2)) / 2
                return max(maxLeft1, maxLeft2)
				
            elif maxLeft1 > minRight2:
                r = partition1 - 1
            else:
                l = partition1 + 1
```

#### d. Illustration

##### i. [1, 11, 16, 45, 78, 99] & [1, 3, 5, 7, 13 ,51, 68, 77, 108]

![4-1](.\imgs\4-1.png)

##### ii. [1, 2, 3, 45, 78, 99] & [1, 3, 5, 7, 13 ,51, 68, 77]

![4-2](.\imgs\4-2.png)

##### iii. [1, 2, 3, 4, 5, 7] & [1, 3, 5, 12, 13, 51, 68, 77]

 1️⃣![4-3-a](.\imgs\4-3-a.png)

2️⃣![4-3-b](.\imgs\4-3-b.png)

##### iv. [81, 82, 83, 88, 89] & [1, 3, 5, 12, 13, 51, 68, 77]

1️⃣![4-4-a](.\imgs\4-4-a.png)

2️⃣![4-4-b](.\imgs\4-4-b.png)

## 3) My code

(1)

- Runtime: 3 ms
- Memory: 95.86 MB
- Time Complexity: $$ O(m+n) $$
  - Traverse all elements once

- Space Complexity: $$ O(m+n) $$
  - A new merged vector


```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size();
        int n = nums2.size();
        int sum = m + n;
        vector<int> nums(sum+1);
        int i = 0;
        int j = 0;
        int k = 0;
        while(i < m && j < n){
            if (nums1[i] < nums2[j]){
                nums.at(k) = nums1[i];
                i++;
            } else {
                nums.at(k) = nums2[j];
                j++;
            };
            k++;
        };

        if(m-i > 0){
            while(i < m){
                nums.at(k) = nums1[i];
                i++;
                k++;
            };
        } else if (n-j > 0) {
            while(j < n){
                nums.at(k) = nums2[j];
                j++;
                k++;
            };
        };

        if(sum % 2 == 1){
            return nums[sum / 2];
        } else {
            return (double)(nums[sum / 2] + nums[(sum / 2) - 1]) / 2;
        }

    }
};
```

(2)

- Runtime: 0 ms
- Memory: 95.01 MB
- Time Complexity: $$ O(m+n) $$
  - Linear in total input size, but stops halfway
- Space Complexity: $$ O(1) $$
  - No additional storage beyond a few variables

```c++
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        int m = nums1.size();
        int n = nums2.size();

        int sum = m + n;
        int mid = sum / 2;

        int i = 0;
        int j = 0;
        int x = 0;
        int y = 0;
        while(i + j < mid + 1){
            y = x;

            if (i < m && j < n){
                if (nums1[i] < nums2[j]){
                    x = nums1[i];
                    i++;
                } else {
                    x = nums2[j];
                    j++;
                }; 
            } else if (i >= m){
                x = nums2[j];
                j++;
            } else if (j >= n){
                x = nums1[i];
                i++;
            } else {
                break;
            };

        };

        if(sum % 2 == 1){
            return x;
        } else {
            return (double)(x + y) / 2;
        }

    }
};
```

## Reference

1. LeetCode [4. Median of Two Sorted Arrays]
   - https://leetcode.com/problems/median-of-two-sorted-arrays/
2. LeetCode Solutions [4. Median of Two Sorted Arrays] by P.-Y. Chen
   - https://walkccc.me/LeetCode/problems/4/