# 2. Add Two Numbers

#Medium #Linked List #Recursion #Math

[toc]

## 1) Question

You are given two **non-empty** linked lists representing two non-negative integers. The digits are stored in **reverse order**, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.

You may assume the two numbers do not contain any leading zero, except the number 0 itself.

**Example 1:**

![addtwonumber1](.\imgs\addtwonumber1.jpg)

```structured text
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Explanation: 342 + 465 = 807.
```

**Example 2:**

```structured text
Input: l1 = [0], l2 = [0]
Output: [0]
```

**Example 3:**

```structured text
Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]
```

**Constraints:**

- The number of nodes in each linked list is in the range `[1, 100]`.
- `0 <= Node.val <= 9`
- It is guaranteed that the list represents a number that does not have leading zeros.

## 2) Solution

### (1) Iterative Approach with Carry Handling

- Time Complexity: $$ O(n) $$
- Space Complexity: $$ O(n) $$

#### a. C++

- Runtime: 2 ms
- Memory: 77.13 MB

```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
 public:
  ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
    ListNode dummy(0);
    ListNode* curr = &dummy;
    int carry = 0;

    while (l1 != nullptr || l2 != nullptr || carry > 0) {
      if (l1 != nullptr) {
        carry += l1->val;
        l1 = l1->next;
      }
      if (l2 != nullptr) {
        carry += l2->val;
        l2 = l2->next;
      }
      curr->next = new ListNode(carry % 10);
      carry /= 10;
      curr = curr->next;
    }

    return dummy.next;
  }
};
```

#### b. Go

- Runtime: 1 ms
- Memory: 6.30 MB

```Go
/**
 * Definition for singly-linked list.
 * type ListNode struct {
 *     Val int
 *     Next *ListNode
 * }
 */
func addTwoNumbers(l1 *ListNode, l2 *ListNode) *ListNode {
    dummy := &ListNode{}
    curr := dummy
    carry := 0

    for l1 != nil || l2 != nil || carry > 0 {
        if l1 != nil{
            carry += l1.Val
            l1 = l1.Next
        }
        if l2 != nil{
            carry += l2.Val
            l2 = l2.Next
        }

        curr.Next = &ListNode{Val: carry % 10}
        carry /= 10
        curr = curr.Next
    }

    return dummy.Next
}
```

#### c. Python

- Runtime: 7 ms
- Memory: 17.87 MB

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: Optional[ListNode], l2: Optional[ListNode]) -> Optional[ListNode]:
        dummy = ListNode()
        curr = dummy
        carry = 0

        while l1 or l2 or carry:
            val1 = l1.val if l1 else 0
            val2 = l2.val if l2 else 0
           
            # carry: quotient, digit: remainder
            carry, digit = divmod(val1 + val2 + carry, 10)
            curr.next = ListNode(digit)
            curr = curr.next

            l1 = l1.next if l1 else None
            l2 = l2.next if l2 else None

        return dummy.next
```

### (2) Recursive Approach

- Time Complexity: $$ O(n) $$
- Space Complexity: $$ O(n) $$
- Runtime: 0 ms
- Memory: 77.06 MB

```c++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2, int carry = 0) {
        if (l1 == nullptr && l2 == nullptr && carry == 0) return nullptr;

        int sum = carry;
        if (l1 != nullptr) sum += l1->val;
        if (l2 != nullptr) sum += l2->val;

        ListNode* result = new ListNode(sum % 10);
        result->next = addTwoNumbers((l1 != nullptr) ? l1->next : nullptr, 
                                     (l2 != nullptr) ? l2->next : nullptr, 
                                     sum / 10);
        return result;
    }
};
```

## 3) My code

- Time Complexity: $$ O(n) $$
  - Each node processed once
- Space Complexity: $$ O(1) $$ auxiliary, $$ O(n) $$ total
  - For the result list
- Runtime: 0 ms
- Memory: 77.21 MB


```c++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* dummy = new ListNode();
        ListNode* result = dummy;
        int roundUp = 0;
        
        while( l1 != nullptr || l2 != nullptr || roundUp != 0){
            int x = (l1 != nullptr)?l1 -> val : 0;
            int y = (l2 != nullptr)?l2 -> val : 0;
            int sum = x + y + roundUp;
            int digit = sum % 10;
            roundUp = sum / 10;
            
            if (l1 != nullptr){
                l1 = l1 -> next;
            };
            if (l2 != nullptr){
                l2 = l2 -> next;
            };

            dummy -> next = new ListNode(digit);
            dummy = dummy -> next;

        };

        return result -> next;
        
    }
};
```

## Reference

1. LeetCode [2. Add Two Numbers]
   - https://leetcode.com/problems/add-two-numbers/
2. LeetCode Solutions [2. Add Two Numbers] by P.-Y. Chen
   - https://walkccc.me/LeetCode/problems/2/
3. Medium [Solving the ‘Add Two Numbers’ Problem on LeetCode — C++ Solutions Walkthrough] by Alexander Obregon
   - https://medium.com/@AlexanderObregon/solving-the-add-two-numbers-problem-on-leetcode-c-solutions-walkthrough-648077404664