# 5. Longest Palindromic Substring

#Medium #Dynamic Programming #Two Pointers #String

[toc]

## 1) Question

Given a string `s`, return *the longest* *palindromic* *substring* in `s`.

The overall run time complexity should be $$O(log (m+n))$$.

**Example 1:**

```structured text
Input: s = "babad"
Output: "bab"
Explanation: "aba" is also a valid answer.
```

**Example 2:**

```structured text
Input: s = "cbbd"
Output: "bb"
```

**Constraints:**

- `1 <= s.length <= 1000`
- `s` consist of only digits and English letters.

## 2) Solution

### (1) Naive

- Time Complexity: $$ O(n^2) $$
- Space Complexity: $$ O(n) $$

#### a. C++

- Runtime: 7 ms
- Memory: 9.38 MB

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        if (s.empty()) return "";
        
        int start = 0, maxLen = 0;
        const int n = s.length();

        for (int i = 0; i < n;) {
            // Optimization 1: Early Exit
            // If the remaining substring is too short to possibly beat the current max, stop.
            if ((n - i) * 2 <= maxLen) break;

            int l = i, r = i;

            // Optimization 2: Skip duplicates (Find the "Center Block")
            // Expand the right boundary of the center while characters match s[i]
            // This handles "a", "aa", "aaa" all in one go.
            while (r < n - 1 && s[r + 1] == s[i]) {
                r++;
            }

            // Important: Jump 'i' to the next character after the center block.
            // We never need to test indices inside the block again.
            i = r + 1;

            // Optimization 3: Expand outwards from the block
            while (l > 0 && r < n - 1 && s[l - 1] == s[r + 1]) {
                l--;
                r++;
            }

            // Update result
            int currentLen = r - l + 1;
            if (currentLen > maxLen) {
                start = l;
                maxLen = currentLen;
            }
        }

        return s.substr(start, maxLen);
    }
};
```

#### b. Go

- Runtime: 0 ms
- Memory: 4.41 MB

```Go
func longestPalindrome(s string) string {
    n := len(s)
	if n < 2 {
		return s
	}

	start, max := 0, 0

	for i := 0; i < n; {
		if (len(s) - i) * 2 <= max {
			break
		}

		l, r := i, i

		for r < n - 1 && s[r + 1] == s[i] {
			r++
		}

		i = r + 1

		for l > 0 && r < n - 1 && s[l - 1] == s[r + 1] {
			l--
			r++
		}

		if curr := r - l + 1; curr > max {
			start = l
			max = curr
		}
	}

	return s[start : start + max]
}
```

#### c. Python

- Runtime: 26 ms
- Memory: 19.54 MB

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if len(s) < 2:
            return s

        start, max_len = 0, 0
        i = 0
        
        while i < len(s):
            if (len(s) - i) * 2 <= max_len:
                break

            l, r = i, i
            
            while r < len(s) - 1 and s[r + 1] == s[i]:
                r += 1
            
            i = r + 1

            while l > 0 and r < len(s) - 1 and s[l - 1] == s[r + 1]:
                l -= 1
                r += 1
            
            if r - l + 1 > max_len:
                start = l
                max_len = r - l + 1

        return s[start : start + max_len]
```

### (2) Manacher

- Time Complexity: $$ O(n) $$
- Space Complexity: $$ O(n) $$

#### a. C++

- Runtime: 7 ms
- Memory: 11.85 MB

```c++
class Solution {
 public:
  string longestPalindrome(string s) {
    const string t = join('@' + s + '$', /*delimiter=*/'#');
    const vector<int> p = manacher(t);
    int maxPalindromeLength = 0;
    int bestCenter = -1;

    for (int i = 0; i < p.size(); ++i)
      if (p[i] > maxPalindromeLength) {
        maxPalindromeLength = p[i];
        bestCenter = i;
      }

    const int l = (bestCenter - maxPalindromeLength) / 2;
    const int r = (bestCenter + maxPalindromeLength) / 2;
    return s.substr(l, r - l);
  }

 private:
  // Returns an array `p` s.t. `p[i]` is the length of the longest palindrome
  // centered at `t[i]`, where `t` is a string with delimiters and sentinels.
  vector<int> manacher(const string& t) {
    vector<int> p(t.length()); // p[i]: palindrome radius at center 'i'
    for (int i = 1, center = 0; i < t.length() - 1; ++i) { // Skip the sentinel characters @ and $.
      // Maximum values of the ending indices of all palindromes
      // In other words, rightmost edge of the current known palindrome.
      const int rightBoundary = center + p[center]; 
      // the symmetric index of i around center.
      const int mirrorIndex = center - (i - center); 
        
      //If 'i' is inside the current palindrome, mirror its value—but it cannot expand beyond rightBoundary.
      if (rightBoundary > i)
        p[i] = min(rightBoundary - i, p[mirrorIndex]);
      // Expands outward symmetrically as long as characters match.
      while (t[i + 1 + p[i]] == t[i - 1 - p[i]])
        ++p[i];
      // Update center if palindrome extends further
      if (i + p[i] > rightBoundary)
        center = i;
    }
    return p;
  }

  string join(const string& s, const char delimiter) {
    string joined;
    for (int i = 0; i < s.length() - 1; ++i) {
      joined += s[i];
      joined += delimiter;
    }
    joined += s.back();
    return joined;
  }
};
```

#### b. Go

- Runtime: 1 ms
- Memory: 5.69 MB

```Go
func longestPalindrome(s string) string {
    if len(s) == 0 {
        return ""
    }

    t := join(s)

    n := len(t)
    p := make([]int, n)
    center, rightBoundary := 0, 0

    maxPalindromeLength := 0
    bestCenter := 0

    for i := 1; i < n - 1; i++ {
        mirrorIndex := center - (i - center)

        if rightBoundary > i {
            p[i] = min(rightBoundary - i, p[mirrorIndex])
        }

        for t[i + 1 + p[i]] == t[i - 1 - p[i]] {
            p[i]++
        }

        if i + p[i] > rightBoundary {
            center = i
            rightBoundary = i + p[i]
        }

        if p[i] > maxPalindromeLength {
            maxPalindromeLength = p[i]
            bestCenter = i
        }

    }

    start := (bestCenter - maxPalindromeLength) / 2
    return s[start : start + maxPalindromeLength]

}

func join(s string) string {
    var sb strings.Builder

    sb.Grow(len(s) * 2 + 3)

    sb.WriteByte('@')
    for i := 0; i < len(s); i++ {
        sb.WriteByte('#')
        sb.WriteByte(s[i])
    }
    sb.WriteByte('#')
    sb.WriteByte('$')

    return sb.String()
}

func min(a, b int) int {
    if b > a {
        return a
    }
    return b
}
```

#### c. Python

- Runtime: 29 ms
- Memory: 19.44 MB

```python
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if not s:
            return ""

        t = "@#" + "#".join(s) + "#$"
        n = len(t)
        p = [0] * n
        right_boundary = 0
        center = 0

        max_palindrome_length = 0
        best_center = 0

        for i in range(1, n - 1):
            mirror_index = center - (i - center)
            if right_boundary > i:
                p[i] = min(right_boundary - i, p[mirror_index])

            while t[i + p[i] + 1] == t[i - p[i] - 1]:
                p[i] += 1
            
            if i + p[i] > right_boundary:
                center, right_boundary = i, i + p[i]

            if p[i] > max_palindrome_length:
                max_palindrome_length = p[i]
                best_center = i
            
        start = (best_center - max_palindrome_length) // 2
        return s[start : start + max_palindrome_length]
```

#### d. Illustration

- banana → @#b#a#n#a#n#a#$

| 'i'               | (0)  | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | (14) |
| :---------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| center            |      | 0    | 1    | 2    | 3    | 3    | 4    | 5    | 5    | 8    | 9    | 10   | 10   | 10   |      |
| char(from center) |      | @    | #    | b    | #    | #    | a    | #    | #    | a    | #    | b    | b    | b    |      |
| p[center]         |      | 0    | 0    | 0    | 0    | 1    | 1    | 0    | 0    | 5    | 0    | 3    | 3    | 3    |      |
| rightBoundary     |      | 0    | 1    | 2    | 4    | 6    | 5    | 7    | 8    | 9    | 10   | 13   | 13   | 13   |      |
| mirrorIndex       |      | -1   | 0    | 1    | 2    | 1    | 2    | 3    | 2    | 7    | 8    | 9    | 8    | 7    |      |
| p[i]              | 0    | 0    | 1    | 0    | 1    | 0    | 3    | 0    | 5    | 0    | 3    | 0    | 1    | 0    | 0    |

- aaaa → @#a#a#a#a#$

| 'i'               |      | (0)  | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | (10) |
| ----------------- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| center            |      |      | 0    | 1    | 2    | 2    | 4    | 5    | 5    | 5    | 5    |      |
| char(from center) |      |      | @    | #    | a    | a    | a    | #    | #    | #    | #    |      |
| p[center]         |      |      | 0    | 0    | 1    | 1    | 3    | 4    | 4    | 4    | 4    |      |
| rightBoundary     |      |      | 0    | 1    | 3    | 3    | 7    | 9    | 9    | 9    | 9    |      |
| mirrorIndex       |      |      | -1   | 0    | 1    | 0    | 3    | 4    | 3    | 2    | 1    |      |
| p[i]              |      | 0    | 0    | 1    | 2    | 3    | 4    | 3    | 2    | 1    | 0    | 0    |

## 4) My code

- Runtime: 2763 ms
- Memory: 244.37 MB
- Time Complexity: $$ O(n^3) $$
  - `rev.insert(0, 1, s[end]);` → $$O(k)$$
  - $$T(n) = \sum_{start=1}^{n-1}\sum_{end=start}^{n-1}O(k) = O(1 +2 + 3 + \dots+n^2)$$

- Space Complexity: $$ O(n) $$
  - `root`, `rev`, and `result` each store at most `n` characters 


```c++
class Solution {
public:
    string longestPalindrome(string s) {
        
        int len = s.length(); 
        string result;

        for (int start = 0; start < len; ++start){
            string root;
            string rev;
            string sub;
            sub += s[start];

            for(int end = start; end < len; ++end){
                root += s[end];
                rev.insert(0, 1, s[end]); 
                if(root == rev && root.length() > result.length()){
                    result = root;
                };
            };

        };

        return result;
    };
    
};
```



## Reference

1. LeetCode [5. Longest Palindromic Substring]
   - https://leetcode.com/problems/longest-palindromic-substring/
2. LeetCode Solutions [5. Longest Palindromic Substring] by P.-Y. Chen
   - https://walkccc.me/LeetCode/problems/5/